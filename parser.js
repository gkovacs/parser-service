// Generated by LiveScript 1.3.1
(function(){
  var child_process, restler, querystring, fs, portnum, getUrl, stdbuf, parsers, segmenter, segmenterResponsesNeeded, terminals, parserResponsesNeeded, express, app, http, httpserver, segment, parseNoSegment;
  child_process = require('child_process');
  restler = require('restler');
  querystring = require('querystring');
  fs = require('fs');
  portnum = 3555;
  getUrl = function(url, params, callback){
    var paramstring, realurl;
    paramstring = querystring.stringify(params);
    if (url.indexOf('/') === -1) {
      url = 'http://localhost:' + portnum + '/' + url;
    }
    if (paramstring === '') {
      realurl = url;
    } else {
      realurl = url + '?' + paramstring;
    }
    return restler.get(realurl).on('complete', function(httpgetresponse){
      return callback(httpgetresponse);
    });
  };
  stdbuf = 'stdbuf -oL cat | ';
  parsers = {};
  parsers['zh'] = child_process.spawn('/bin/sh', ['-c', stdbuf + 'java -mx2g -Dfile.encoding=UTF-8 -jar BerkeleyParser-1.7.jar -chinese -gr chn_sm5.gr']);
  parsers['en'] = child_process.spawn('/bin/sh', ['-c', stdbuf + 'java -mx2g -Dfile.encoding=UTF-8 -jar BerkeleyParser-1.7.jar -gr eng_sm6.gr']);
  segmenter = child_process.spawn('/bin/sh', ['-c', stdbuf + 'java -mx2g -cp u/nlp/distrib/stanford-segmenter-2012-11-11/seg.jar edu.stanford.nlp.ie.crf.CRFClassifier -sighanCorporaDict u/nlp/distrib/stanford-segmenter-2012-11-11/data -sighanPostProcessing true -loadClassifier u/nlp/distrib/stanford-segmenter-2012-11-11/data/ctb.gz -serDictionary u/nlp/distrib/stanford-segmenter-2012-11-11/data/dict-chris6.ser.gz -testFile /dev/stdin']);
  segmenterResponsesNeeded = {};
  if (segmenter != null) {
    segmenter.stdout.on('data', function(data){
      var result, query, ref$;
      result = data.toString().trim();
      console.log('segstdout: ' + result);
      query = result.split(' ').join('').trim();
      if (segmenterResponsesNeeded[query] != null) {
        segmenterResponsesNeeded[query](result);
        return ref$ = segmenterResponsesNeeded[query], delete segmenterResponsesNeeded[query], ref$;
      }
    });
    segmenter.stderr.on('data', function(data){
      return console.log('segstderr: ' + data);
    });
  }
  terminals = function(s){
    var output, current_terminal, i$, len$, c, last_paren_type, to_print, ref$, tag, terminal;
    output = [];
    current_terminal = [];
    for (i$ = 0, len$ = s.length; i$ < len$; ++i$) {
      c = s[i$];
      if (c === '(') {
        last_paren_type = '(';
        current_terminal = [];
      } else if (c === ')') {
        if (last_paren_type === '(') {
          if (current_terminal.length > 0) {
            to_print = current_terminal.join('');
            ref$ = to_print.split(' '), tag = ref$[0], terminal = ref$[1];
            output.push(terminal);
          }
        }
        last_paren_type = ')';
        current_terminal = [];
      } else {
        current_terminal.push(c);
      }
    }
    return output.join('').split(' ').join('').trim();
  };
  parserResponsesNeeded = {};
  (function(){
    var i$, ref$, results$ = [];
    for (i$ in ref$ = parsers) {
      results$.push((fn$.call(this, i$, ref$[i$])));
    }
    return results$;
    function fn$(lang, parser){
      parserResponsesNeeded[lang] = [];
      parser.stdout.on('data', function(data){
        var result, encoding, curCallback;
        result = data.toString(encoding = 'utf8').trim();
        console.log(parserResponsesNeeded[lang]);
        if (parserResponsesNeeded[lang].length > 0) {
          curCallback = parserResponsesNeeded[lang].shift();
          curCallback(result);
        }
        return console.log('parserstdout: ' + result);
      });
      return parser.stderr.on('data', function(data){
        return console.log('parserstderr: ' + data);
      });
    }
  })();
  express = require('express');
  app = express();
  http = require('http');
  httpserver = http.createServer(app);
  httpserver.listen(portnum);
  app.get('/', function(req, res){
    return res.end('either segment or parse');
  });
  segment = function(params, callback){
    var sentence, query, encoding;
    sentence = params.sentence;
    if (sentence != null) {
      console.log('segment sentence: ' + sentence);
      query = sentence.split(' ').join('').trim();
      segmenterResponsesNeeded[query] = function(segmented){
        if (segmented != null) {
          console.log('got segmented: ' + segmented);
          return callback(segmented);
        }
      };
      return segmenter.stdin.write(query + '\n\n\n\n', encoding = 'utf8');
    } else {
      return callback('need to provide sentence parameter');
    }
  };
  app.get('/segment', function(req, res){
    return segment(req.query, function(segmented){
      return res.end(segmented);
    });
  });
  parseNoSegment = function(params, callback){
    var sentence, lang, query, encoding;
    sentence = params.sentence, lang = params.lang;
    if (sentence == null) {
      callback('need to provide sentence parameter');
      return;
    }
    lang = lang != null ? lang : 'en';
    query = sentence.split(' ').join('').trim();
    console.log(lang);
    console.log(query);
    parserResponsesNeeded[lang].push(function(parsed){
      if (parsed != null) {
        return callback(parsed);
      }
    });
    return parsers[lang].stdin.write(sentence + '\n', encoding = 'utf8');
  };
  app.get('/parseNoSegment', function(req, res){
    return parseNoSegment(req.query, function(parsed){
      return res.end(parsed);
    });
  });
  app.get('/parse', function(req, res){
    var sentence, lang, ref$;
    sentence = req.query.sentence;
    if (sentence == null) {
      res.end('need to provide sentence parameter');
      return;
    }
    lang = (ref$ = req.query.lang) != null ? ref$ : 'en';
    if (lang !== 'zh') {
      if (parsers[lang] == null) {
        lang = 'zh';
      }
      parseNoSegment({
        'lang': lang,
        'sentence': sentence
      }, function(parsed){
        return res.end(parsed);
      });
    } else {
      console.log('sentence is:' + sentence);
      return segment({
        'lang': lang,
        'sentence': sentence
      }, function(segmented){
        console.log('newly segmented sentence:' + segmented);
        return parseNoSegment({
          'lang': lang,
          'sentence': segmented
        }, function(parsed){
          console.log('parsed output:' + parsed);
          if (parsed != null) {
            res.end(parsed);
          }
        });
      });
    }
  });
}).call(this);
